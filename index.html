<!DOCTYPE html>
<html>
<head>


<link href="./data/toastr.min.css" rel="stylesheet"></link>
<link href="./data/jquery-ui.css" rel="stylesheet"></link>
<link href="./data/theme.css" rel="stylesheet"></link>


<script src="./data/jquery-ui.js"></script>
<script src="./data/toastr.min.js"></script>
<script src="./data/konva.min.js"></script>
<script src="./data/global_value.js"></script>

<meta charset="utf-8" />
<title>仙劍破壞神</title>
</head>

<body style="background-color:#202025">

<div id="container" style="background-color:black; top:0px; left:0px; position:absolute;"></div>

<div style="position:absolute; left:0px; top:0px;">
	<div id="mouse_pos" style="color:white">Mouse position: 0,0</div>
	<select id="map_select" onchange='change_map(this[this.selectedIndex].text);'>
		<option selected="true">0001</option>
		<option>0002</option>
		<option>0003</option>
		<option>0004</option>
		<option>0005</option>
	</select>
	<button id="atk">物理攻擊</button>
	<button id="matk">法術攻擊</button>
	<button id="def">防禦</button>
	<button id="hurt">受到攻擊</button>
	<button id="dead">死亡</button>
	</br>
	<span id="file_name" style="color:white"></span>
	<!--<input id='upload_file' type="file"></input>-->
	
</div>

<table style="height: 200px; overflow-y: scroll; background-color:white; position:absolute; left:850px; top:0px">
	<thead><tr><th>工作日志：</th><tr></thead>
	<tbody>
		<tr><td>（2022年11月9日）加入五張地圖並上傳網頁伺服器測試</td></tr>
		<tr><td>（2022年11月7日）加入0001~2地圖測試兩個</td></tr>
		<tr><td>（2022年11月6日）地圖破圖問題修正</td></tr>
		<tr><td>（2022年10月16日）解析map.mkf地圖</td></tr>
		<tr><td>（2022年10月10日）加入地圖,角色走路動作顯示</td></tr>
		<tr><td>（2022年10月9日）物理攻擊動作微調圖片大小</td></tr>
		<tr><td>（2022年10月1日）滑鼠左键讓角色移動位置</td></tr>
		<tr><td>（2022年9月30日）滑鼠左键讓角色改變位置</td></tr>
		<tr><td>（2022年9月29日）角色動作顯示，以按鈕方式測試</td></tr>
		<tr><td>（2022年9月28日）擬定計劃，設計仙劍破壞神網頁游戲</td></tr>
	</tbody>
</table>
</body>

<script>
let fileInput=document.getElementById('upload_file');//querySelector("input[type='file']");

let s_pos={x:77, y:58}, e_pos={x:33, y:15}, map_pos={x:77, y:58},range=32;
var img_main_char = new Image(),main_char,velocity=1.5,offset_x=range*tile_x2,offset_y=range*tile_y2; let img2_y=46;
var width = 2*offset_x-tile_x2;//window.innerWidth;
var height = 2*offset_y-tile_y2;//window.innerHeight;
var stage = new Konva.Stage({
	container: 'container',
	width: width,
	height: height,
});
var ctx = map_layer.getCanvas()._canvas.getContext('2d');
let map_data=[],Template_Data=[],gop=[];
let mousePos;

var zhao_animations = {
	//layer1 = 0
	leftup: [3*26,0, 26,46,   4*26,0, 26,46,    5*26,0, 26,46],
	rightup: [6*26,0, 26,46,   7*26,0, 26,46,    8*26,0, 26,46],
	leftdown: [0*26,0, 26,46,   1*26,0, 26,46,    2*26,0, 26,46],
	rightdown: [9*26,0, 26,46,   10*26,0, 26,46,    11*26,0, 26,46],
	
	//layer2 = 46
	idle: [0, img2_y, 56,63],
	atk: [7*56,img2_y, 56,63,  8*56+73*0,img2_y,73,74,     8*56+73*1,img2_y, 73,74],
	matk: [5*56,img2_y, 56,63, 6*56,img2_y, 56,63],
	def: [3*56,img2_y, 56,63],
	hurt: [4*56,img2_y, 56,63],
	dead: [2*56,img2_y, 56,63,],
};
function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
}
function info_update(evt) {
	let mouse_pos=document.getElementById("mouse_pos");
	let mp=getMousePos(layer.getCanvas()._canvas, evt);
	let p=mousePos2mapPos(mp);
	
	//mouse_pos.style.top=p.y;
	//mouse_pos.style.left=p.x;
	cursor.x(p.x*tile_x2);
	cursor.y(p.y*tile_y2);
	
	let a={x:(map_pos.x+p.x-range/2),y:(map_pos.y+p.y-range/2)};
	mouse_pos.innerHTML="x:"+a.x+"("+mp.x+"), y:"+a.y+"("+mp.y+")";
	return a;
}
layer.getCanvas()._canvas.addEventListener('mousedown', function(evt) {
	let e_pos=info_update(evt);
	
	//main_char.y(offset_y-36);
	
	if(e_pos.x>s_pos.x&&e_pos.y>s_pos.y) {  main_char.animation('rightdown');}
	else if(e_pos.x>s_pos.x&&e_pos.y<s_pos.y) { main_char.animation('rightup');}
	else if(e_pos.x<s_pos.x&&e_pos.y>s_pos.y) { main_char.animation('leftdown');}
	else if(e_pos.x<s_pos.x&&e_pos.y<s_pos.y) { main_char.animation('leftup');}
	
	//s_pos=e_pos;
	
	
	draw_map(e_pos.x,e_pos.y);
	
}, false);

let char_speed=.1;
var anim = new Konva.Animation(function (frame) {
	if(e_pos.x!=s_pos.x||e_pos.y!=s_pos.y) {
		let p=[];
		p.x=e_pos.x+map_pos.x;
		p.y=e_pos.y+map_pos.y;
		
		
		
		if(e_pos.x>s_pos.x) e_pos.x-=char_speed; 
		if(e_pos.x<s_pos.x) e_pos.x+=char_speed; 
			
		if(e_pos.y>s_pos.y) e_pos.y-=char_speed; 
		if(e_pos.y<s_pos.y) e_pos.y+=char_speed; 
	}	
}, layer);
moving=false;
function mousePos2mapPos(p){
	p={x:Math.round(p.x/tile_x2),y:Math.round(p.y/tile_y2)};
	if(p.x%2!=p.y%2) p.y--;

	return p;
}
layer.getCanvas()._canvas.addEventListener('mousemove', function(e) {info_update(e);}, false);

var cursor = new Konva.Shape({
        sceneFunc: function (context, shape) {
  context.beginPath();
  context.moveTo(16, 0);
  context.lineTo(32, 7.5);
  context.lineTo(16, 15);
  context.lineTo(0, 7.5);
  context.closePath();

  // (!) Konva specific method, it is very important
  context.fillStrokeShape(shape);
  },
  stroke: 'green',
	strokeWidth: 2,
	offset: {
	  x: 16,
	  y: 7.5,
	},
});
layer.add(cursor);	
stage.add(map_layer,layer);

img_main_char.src = './data/img/zhao.png';
img_main_char.onload = function () {
	main_char = new Konva.Sprite({
		x:offset_x,
		y:offset_y-46,
		image: img_main_char,
		animation: 'idle',
		animations: zhao_animations,
		frameRate: 4,
		frameIndex: 0,
	});

	// add the shape to the layer
	layer.add(main_char);
				
	
	
	//main_char.x(main_char.x()+13);
	//main_char.y(main_char.y()-46*2);
	// start sprite animation
	main_char.start();
	
	// resume transition
	document.getElementById('atk').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.animation('atk');
			main_char.on('frameIndexChange.button', function () {
				if (this.frameIndex() == 2) {
					setTimeout(function () {
						main_char.animation('idle');
						main_char.off('.button');
					}, 1000 / main_char.frameRate());
				}
			});
		},
		false
	);
	document.getElementById('matk').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.animation('matk');
			main_char.on('frameIndexChange.button', function () {
				if (this.frameIndex() === 1) {
					setTimeout(function () {
						main_char.animation('idle');
						main_char.off('.button');
					}, 1000 / main_char.frameRate());
				}
			});
		},
		false
	);
	document.getElementById('hurt').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.animation('hurt');
			if (main_char.frameIndex() == 0) {
				setTimeout(function () {
					main_char.animation('idle');
					main_char.off('.button');
				}, 1000 / main_char.frameRate());
			}
		},
		false
	);
	document.getElementById('dead').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.animation('dead');	
		},false);
	document.getElementById('def').addEventListener('click', function () {
		//main_char.y(offset_y);
		main_char.animation('def');
	},false);
	
};

map_init();
function change_map(path="0001"){
	
	//alert("path",path);
	
	read_map(path);
	draw_map();
	draw_mgo();
}

async function map_init(path="0001"){
	
	if(map_data.length==0) {
		map_data=make_arr();
	}
	await read_map(path);
	draw_map();
	
	anim.start(); 
}
/*fileInput.addEventListener('change', function (e) {
	let fn=fileInput.files[0].name;
	
	var r = new FileReader();
		
	fn=fileInput.files[0].name.split('.')[0];
	
	r.onload=function(e){read_map(e.target.result);};
	r.readAsArrayBuffer(fileInput.files[0]);
	toastr["success"]("read "+fn);
}, false);*/
async function read_gop(path="0002",max_gop){
	console.log('max_gop=',max_gop);
	
	function read_img(){
		for(let c=0;c<=max_gop;c++){
			gop[c]=new Image();
			gop[c].src="./data/img/gop/"+path+"/"+c+".png";
		}
	}
	return await read_img();
}
async function read_map(file_path="0002"){
	let response = await fetch("./data/map/map"+file_path);
	const buffer = await response.arrayBuffer(); // 取得 ArrayBuffer 實例
	var da=new Uint32Array(buffer);

	//da=read_bin(da);
	//test_a=da;
	let max_gop=0;
	console.log(da.length);
	for(let row=0;row<128;row++){
		for(let col=0;col<128;col++){
			let x=col*tile_x2, y=row*15+(col%2)*tile_y2;
			let c=row*128 + col;
			let bytes = getIntBytes(da[c],4);
			//let bytes = da.slice(c,c+4);
			
			//let barrier=(b2[0]&0x20==0x20)?true:false; //b2[1]+=255; 
			//console.log('x',col,'y',row,'[',bytes[0],bytes[1],bytes[2],bytes[3],']');
			
			let bin=PrefixInteger(bytes[2].toString(2),8);
			if(bin[3]=='1') bytes[3]+=256;
			//ctx.drawImage(gop[bytes[3]], x, y); //下層
			
			
			bin=PrefixInteger(bytes[0].toString(2),8);
			if(bin[3]=='1') bytes[1]+=256;
			if(bytes[1]>0)bytes[1]-=1;
			//if(451>=bytes[1]&&bytes[1]>0) ctx.drawImage(gop[bytes[1]], x, y); //上層
			
			if(bytes[3]>max_gop) max_gop=bytes[3];
			if(bytes[1]>max_gop) max_gop=bytes[1];
			
			map_data[row][col]={down_layer:bytes[3],up_layer:bytes[1],barrier:false}
		}
	}
	read_gop(file_path,max_gop);
}
function read_bin(file_path){
	let rawFile = new XMLHttpRequest();
	rawFile.open("GET", file_path, true);
	rawFile.responseType='arraybuffer';
	rawFile.onload = function(e) {
		
		return this.response;
	};
	rawFile.send();
	
	/*const response = await fetch(file_path);
	const buffer = await response.arrayBuffer(); // 取得 ArrayBuffer 實例
	return (buffer.byteLength) // 查看當前這個 ArrayBuffer 有多少 bytes。*/

}
function getIntBytes( x,i = 4){
    var bytes = [];
    
    do {
    bytes[--i] = x & (255);
    x = x>>8;
    } while ( i )
    return bytes;
}
function Map_Assert(x,y){
	
	return (0 <= x && x <= 127 && 0 <= y && y <= 127)?true:false;	
}


function draw_map(px=map_pos.x,py=map_pos.y,r=64){
	px=Math.round(px);
	py=Math.round(py);
	
	map_pos.x=px; map_pos.y=py;
	if(px%2==1) map_pos.x=px+=1;

	let r2=r/2,r4=r2/2,main_flag=false;
	for(let row=0;row<r2;row++){
		for(let col=0;col<r;col++){
			let x=(col)*tile_x2-tile_x2, y=(row)*15+(col)%2*tile_y2-tile_y2;
			
			let dx=col+px-r2,dy=row+py-r4;
			let c=(Map_Assert(dx,dy))?map_data[dy][dx]:blank;
			ctx.drawImage(gop[c.down_layer], x, y); //下層
			if(c.up_layer>0)ctx.drawImage(gop[c.up_layer], x, y); //up層	
			
			
			if(s_pos.x==dx&&s_pos.y==dy) {
				main_char.visible(true);
				main_char.x(x); 
				main_char.y(y);
				main_flag=true;
			}
			
		}
	}
	if(main_flag==false) main_char.visible(false);
}
function PrefixInteger(num, length) {
	return (Array(length).join('0') + num).slice(-length);
}
function make_arr(){
	let arr=new Array(128);
	for(let i=0;i<arr.length;i++){
		arr[i]=new Array(128);
		for(let j=0;j<arr[i].length;j++){
			arr[i][j]=new Array(2);
			for(let k=0;k<arr[i][j].length;k++)
				arr[i][j][k]=0;
		}
	}
	return arr;
}

</script>
</html>
