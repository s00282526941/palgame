<!DOCTYPE html>
<html>
<head>


<link href="./data/toastr.min.css" rel="stylesheet"></link>
<link href="./data/jquery-ui.css" rel="stylesheet"></link>
<link href="./data/theme.css" rel="stylesheet"></link>

<meta charset="utf-8" />
<title>仙劍破壞神</title>
</head>

<body style="background-color:#202025">

<div id="container" style="background-color:black; top:0px; left:0px; position:absolute;"></div>

<div style="position:absolute; left:0px; top:0px;">
	<div id="mouse_pos" style="color:white">Mouse position: 0,0</div>
	<select id="map_select" onchange='change_map(this[this.selectedIndex].text);'>
		<option selected="true">0001</option>
		<option>0002</option>
		<option>0003</option>
		<option>0004</option>
		<option>0005</option>
	</select>
	<button id="atk">物理攻擊</button>
	<button id="matk">法術攻擊</button>
	<button id="def">防禦</button>
	<button id="hurt">受到攻擊</button>
	<button id="dead">死亡</button>
	</br>
	<span id="file_name" style="color:white"></span>
	<!--<input id='upload_file' type="file"></input>-->
	
</div>

<table style="height: 200px; overflow-y: scroll; background-color:white; position:absolute; left:850px; top:0px">
	<thead><tr><th>工作日志：</th><tr></thead>
	<tbody>
		<tr><td>（2022年11月9日）加入五張地圖並上傳網頁伺服器測試</td></tr>
		<tr><td>（2022年11月7日）加入0001~2地圖測試兩個</td></tr>
		<tr><td>（2022年11月6日）地圖破圖問題修正</td></tr>
		<tr><td>（2022年10月16日）解析map.mkf地圖</td></tr>
		<tr><td>（2022年10月10日）加入地圖,角色走路動作顯示</td></tr>
		<tr><td>（2022年10月9日）物理攻擊動作微調圖片大小</td></tr>
		<tr><td>（2022年10月1日）滑鼠左键讓角色移動位置</td></tr>
		<tr><td>（2022年9月30日）滑鼠左键讓角色改變位置</td></tr>
		<tr><td>（2022年9月29日）角色動作顯示，以按鈕方式測試</td></tr>
		<tr><td>（2022年9月28日）擬定計劃，設計仙劍破壞神網頁游戲</td></tr>
	</tbody>
</table>
</body>

<script src="./data/jquery.min.js"></script>
<script src="./data/jquery-ui.js"></script>
<script src="./data/toastr.min.js"></script>
<script src="./data/konva.min.js"></script>
<script src="./data/global_value.js"></script>

<script>
//let fileInput=document.getElementById('upload_file');//querySelector("input[type='file']");

function getMousePos(canvas, evt) {
	var rect = canvas.getBoundingClientRect();
	return {
		x: evt.clientX - rect.left,
		y: evt.clientY - rect.top
	};
}
function mousePos2mapPos(p){
	p={x:Math.round((p.x-width/2)/tile_x2),y:Math.round((p.y-height/2)/tile_y)};
	if(p.x%2!=p.y%2) p.y--;

	return p;
}
function cursor_pos(p){
	p={x:Math.round(p.x/tile_x2)*tile_x2,y:Math.round(p.y/tile_y2)*tile_y2};
	if(p.x%2!=p.y%2) p.y--;

	return p;
}
function info_update(evt) {
	let mouse_pos=document.getElementById("mouse_pos");
	let mp=getMousePos(layer.getCanvas()._canvas, evt);
	let p=mousePos2mapPos(mp);
	
	//mouse_pos.style.top=p.y;
	//mouse_pos.style.left=p.x;
	
	let cp=cursor_pos(mp);
	cursor.x(cp.x); cursor.y(cp.y);
	
	let a={x:Math.round(map_pos.x+p.x),y:Math.round(map_pos.y+p.y)};
	mouse_pos.innerHTML="x:"+a.x+"("+mp.x+"), y:"+a.y+"("+mp.y+")";
	return a;
}
layer.getCanvas()._canvas.addEventListener('mousedown', function(evt) {
	e_pos=info_update(evt);
	
	//main_char.y(offset_y-36);
	
	if(e_pos.x>s_pos.x&&e_pos.y>s_pos.y) {  main_char.animation('rightdown');}
	else if(e_pos.x>s_pos.x&&e_pos.y<s_pos.y) { main_char.animation('rightup');}
	else if(e_pos.x<s_pos.x&&e_pos.y>s_pos.y) { main_char.animation('leftdown');}
	else if(e_pos.x<s_pos.x&&e_pos.y<s_pos.y) { main_char.animation('leftup');}
	
	//alert(e_pos.x,e_pos.y);
	main_char.start();
}, false);
var anim = new Konva.Animation(function (frame) {
	if(e_pos.x!=s_pos.x||e_pos.y!=s_pos.y) {
		
		if(e_pos.x>s_pos.x) s_pos.x+=char_speed; 
		if(e_pos.x<s_pos.x) s_pos.x-=char_speed; 
			
		if(e_pos.y>s_pos.y) s_pos.y+=char_speed; 
		if(e_pos.y<s_pos.y) s_pos.y-=char_speed; 
		
		draw_map(s_pos.x,s_pos.y);
		draw_gate();
		
	}	
	//else main_char.stop();
}, layer);

layer.getCanvas()._canvas.addEventListener('mousemove', function(e) {info_update(e);}, false);


img_main_char.onload = function () {
	main_char = new Konva.Sprite({
		x:offset_x,
		y:offset_y-46,
		width:26,
		height:46,
		image: img_main_char,
		animation: 'idle',
		animations: zhao_animations,
		frameRate: 4,
		frameIndex: 0,
	});

	// add the shape to the layer
	layer.add(main_char);
		
	// start sprite animation
	main_char.start();
	
	// resume transition
	document.getElementById('atk').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.start();
			main_char.animation('atk');
			main_char.on('frameIndexChange.button', function () {
				if (this.frameIndex() == 2) {
					setTimeout(function () {
						main_char.animation('idle');
						main_char.off('.button');
					}, 1000 / main_char.frameRate());
				}
			});
		},
		false
	);
	document.getElementById('matk').addEventListener('click', 
		function () {
			main_char.start();//main_char.y(offset_y);
			main_char.animation('matk');
			main_char.on('frameIndexChange.button', function () {
				if (this.frameIndex() == 1) {
					setTimeout(function () {
						main_char.animation('idle');
						main_char.off('.button');
					}, 1000 / main_char.frameRate());
				}
			});
		},
		false
	);
	document.getElementById('hurt').addEventListener('click', 
		function () {
			main_char.start();//main_char.y(offset_y);
			main_char.animation('hurt');
			if (main_char.frameIndex() == 0) {
				setTimeout(function () {
					main_char.animation('idle');
					main_char.off('.button');
				}, 1000 / main_char.frameRate());
			}
		},
		false
	);
	document.getElementById('dead').addEventListener('click', 
		function () {
			//main_char.y(offset_y);
			main_char.animation('dead');	
		},false);
	document.getElementById('def').addEventListener('click', function () {
		//main_char.y(offset_y);
		main_char.animation('def');
	},false);
	
};
function change_map(path="0001",p){
	read_map(path);
	read_gate(path);
	s_pos=e_pos=p;
	draw_map(p.x,p.y);
}

async function map_init(path="0001"){
	
	if(map_data.length==0) {
		map_data=make_arr();
	}
	await read_map(path);
	draw_map();
	read_gate(path);
	
	anim.start(); 
}
/*fileInput.addEventListener('change', function (e) {
	let fn=fileInput.files[0].name;
	
	var r = new FileReader();
		
	fn=fileInput.files[0].name.split('.')[0];
	
	r.onload=function(e){read_map(e.target.result);};
	r.readAsArrayBuffer(fileInput.files[0]);
	toastr["success"]("read "+fn);
}, false);*/

async function read_gop(path="0002",max_gop){
	console.log('max_gop=',max_gop);
	
	function read_img(){
		for(let c=0;c<=max_gop;c++){
			gop[c]=new Image();
			gop[c].src="./data/img/gop/"+path+"/"+c+".png";
		}
	}
	return await read_img();
}

async function read_map(file_path="0002"){
	let response = await fetch("./data/map/map"+file_path);
	const buffer = await response.arrayBuffer(); // 取得 ArrayBuffer 實例
	var da=new Uint32Array(buffer);

	//da=read_bin(da);
	//test_a=da;
	let max_gop=0;
	console.log(da.length);
	for(let row=0;row<128;row++){
		for(let col=0;col<128;col++){
			let x=col*tile_x2, y=row*15+(col%2)*tile_y2;
			let c=row*128 + col;
			let bytes = getIntBytes(da[c],4);
			//let bytes = da.slice(c,c+4);
			
			//let barrier=(b2[0]&0x20==0x20)?true:false; //b2[1]+=255; 
			//console.log('x',col,'y',row,'[',bytes[0],bytes[1],bytes[2],bytes[3],']');
			
			let bin=PrefixInteger(bytes[2].toString(2),8);
			if(bin[3]=='1') bytes[3]+=256;
			//ctx.drawImage(gop[bytes[3]], x, y); //下層
			
			
			bin=PrefixInteger(bytes[0].toString(2),8);
			if(bin[3]=='1') bytes[1]+=256;
			if(bytes[1]>0)bytes[1]-=1;
			//if(451>=bytes[1]&&bytes[1]>0) ctx.drawImage(gop[bytes[1]], x, y); //上層
			
			if(bytes[3]>max_gop) max_gop=bytes[3];
			if(bytes[1]>max_gop) max_gop=bytes[1];
			
			map_data[row][col]={down_layer:bytes[3],up_layer:bytes[1],barrier:false}
		}
	}
	read_gop(file_path,max_gop);
	
}
function read_bin(file_path){
	let rawFile = new XMLHttpRequest();
	rawFile.open("GET", file_path, true);
	rawFile.responseType='arraybuffer';
	rawFile.onload = function(e) {
		
		return this.response;
	};
	rawFile.send();
	
	/*const response = await fetch(file_path);
	const buffer = await response.arrayBuffer(); // 取得 ArrayBuffer 實例
	return (buffer.byteLength) // 查看當前這個 ArrayBuffer 有多少 bytes。*/

}
function getIntBytes( x,i = 4){
    var bytes = [];
    
    do {
    bytes[--i] = x & (255);
    x = x>>8;
    } while ( i )
    return bytes;
}
function Map_Assert(x,y){
	
	return (0 <= x && x <= 127 && 0 <= y && y <= 127)?true:false;	
}
function draw_map(px=map_pos.x,py=map_pos.y,r=64){
	px=Math.round(px);
	py=Math.round(py);
	
	map_pos.x=px; map_pos.y=py;
	if(px%2==1) map_pos.x=px+=1;

	let r2=r/2,r4=r2/2,main_flag=false;// main_char.visible(true);
	for(let row=0;row<r2;row++){
		for(let col=0;col<r;col++){
			let x=(col)*tile_x2-tile_x2, y=(row)*15+(col)%2*tile_y2-tile_y2;
			
			let dx=col+px-r2,dy=row+py-r4;
			let c=(Map_Assert(dx,dy))?map_data[dy][dx]:blank;
			ctx.drawImage(gop[c.down_layer], x, y); //下層
			if(c.up_layer>0)ctx.drawImage(gop[c.up_layer], x, y); //up層	
			
			
			if(dx<s_pos.x&&s_pos.x<dx&&dy<s_pos.y&&s_pos.y<dy) {
				x=(s_pos.x)*tile_x2-tile_x2, y=(s_pos.y)*15+(s_pos.x)%2*tile_y2-tile_y2;
				main_char.x(x+5); 
				main_char.y(y-35);
				main_flag=true;
			}
		}
	}
	
	//if(main_flag==false) main_char.visible(false);
}
function PrefixInteger(num, length) {
	return (Array(length).join('0') + num).slice(-length);
}
function make_arr(){
	let arr=new Array(128);
	for(let i=0;i<arr.length;i++){
		arr[i]=new Array(128);
		for(let j=0;j<arr[i].length;j++){
			arr[i][j]=new Array(2);
			for(let k=0;k<arr[i][j].length;k++)
				arr[i][j][k]=0;
		}
	}
	return arr;
}



var tooltip = new Konva.Label({
	x: 170,
	y: 75,
	opacity: 0.75,
});
tooltip.add(
	new Konva.Tag({
		fill: 'black',
		pointerDirection: 'down',
		pointerWidth: 10,
		pointerHeight: 10,
		lineJoin: 'round',
		shadowColor: 'black',
		shadowBlur: 10,
		shadowOffsetX: 10,
		shadowOffsetY: 10,
		shadowOpacity: 0.5,
	})
);
tooltip.add(
	new Konva.Text({
		text: 'Tooltip pointing down',
		fontFamily: 'Calibri',
		fontSize: 18,
		padding: 5,
		fill: 'white',
	})
);
var transport = new Konva.Ellipse({
	x: 20,
	y: 20,
	radiusX: tile_x*1.5,
	radiusY: tile_y*1.5,
	fill: 'white',
	opacity: 0.3,
	
	/*offset: {
		x: 0,
		y: tile_y*2,
	},*/
});
/*transport.on('mouseover', function () {
	this.opacity(0.3);
});

transport.on('mouseout', function () {
	this.opacity(0);
});*/


// add the shape to the layer
//let test_b;
function collisionCheck(obj1,obj2){
	//test_a=obj1;
	//test_b=obj2;
	if(obj2.x()<obj1.x()&&obj1.x()<obj2.x()+obj2.width() && obj2.y()<obj1.y()&&obj1.y()<obj2.y()+obj2.height()) return true;
	if(obj2.x()<obj1.x()+obj1.width()&&obj1.x()+obj1.width()<obj2.x()+obj2.width() && obj2.y()<obj1.y()&&obj1.y()<obj2.y()+obj2.height()) return true;
	if(obj2.x()<obj1.x()+obj1.width()&&obj1.x()+obj1.width()<obj2.x()+obj2.width() && obj2.y()<obj1.y()+obj1.height()&&obj1.y()+obj1.height()<obj2.y()+obj2.height()) return true;
	if(obj2.x()<obj1.x()&&obj1.x()<obj2.x()+obj2.width() && obj2.y()<obj1.y()+obj1.height()&&obj1.y()+obj1.height()<obj2.y()+obj2.height()) return true;
	
	return false;
} 
function dist(point,circle) {
	return (Math.sqrt((point.x-circle.x) ** 2 + (point.y - circle.y) ** 2) < circle.radius);
}
function draw_gate(px=map_pos.x,py=map_pos.y){
	let r=64,r2=r/2,r4=r2/2,min_len=width;
	
	for(let i=0;i<gate[map_id].length;i++){
		let g=gate[map_id][i];
		let s_pos=g.s_pos;
		console.log('map_id',map_id);
		//test_a=g;
		
		let col=s_pos.x-px+r2,row=(s_pos.y>py)?s_pos.y-py+r4:r4-(py-s_pos.y);
		let x=col*tile_x2-tile_x2, y=row*tile_y;
		
		
		let len=dist(s_pos,map_pos);
		
		if(0<x&&x<width || 0<y&&y<height && min_len>len){
			min_len=len;
			tooltip.children[1].text(g.name);
			tooltip.position({x:x,y:y});
			transport.position({x:x,y:y});
			
			console.log(i,x,y);
			
			if(collisionCheck(main_char,transport)==true) change_map(g.path,g.e_pos);
		}
		 
		
	}
}
layer.add(transport,tooltip);
gate[1]=[];//余杭村
gate[1].push({name:"李大娘的客棧", path:"0002",s_pos:{x:78,y:54},e_pos:{x:0,y:110}});
gate[1].push({name:"往漁市場", path:"0002",s_pos:{x:125,y:75},e_pos:{x:0,y:110}});
gate[2]=[];//漁市場
gate[2].push({name:"余杭村", path:"0001",s_pos:{x:0,y:110},e_pos:{x:122,y:75}});
gate[2].push({name:"往仙靈島", path:"0003",s_pos:{x:73,y:85},e_pos:{x:42,y:53}});
gate[3]=[];//仙靈島
gate[3].push({name:"往漁市場", path:"0002",s_pos:{x:41,y:54},e_pos:{x:72,y:86}});
//gate[3].push({name:"蓮花池", path:"0003",s_pos:{x:128,y:8},e_pos:{x:42,y:53}});

gate[10]=[];//客棧
gate[10].push({name:"余杭村", path:"0001",s_pos:{x:41,y:54},e_pos:{x:72,y:86}});
function read_gate(path="0002"){
	map_id=parseInt(path);
	
}

map_init();



</script>
</html>
